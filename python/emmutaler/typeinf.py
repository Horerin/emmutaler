from emmutaler.log import get_logger
from emmutaler.util import get_args
import sys
import ida_typeinf
import idaapi
import idautils
import idc
import time
import os
import logging

BAD_MODIFIERS = ["static", "__fastcall", "__cdecl"]

def print_item_type(ea):
    defstr = ida_typeinf.print_type(ea, ida_typeinf.PRTYPE_SEMI)
    if defstr is None:
        return None
    for bad_mod in BAD_MODIFIERS:
        defstr = defstr.replace(bad_mod, "")
    return defstr

class GenHeader:
    """Responsible for generating an actual includable header from IDA.
    """
    def __init__(self, outfile):
        self.log = get_logger(__name__ + ".GenHeader")
        self.log.setLevel(logging.DEBUG)
        self.outfile = outfile
        self.sys_includes = []
        self.include_defs = True
        self.handled_ordinals = set()
        self.blocked = ["__uint128_t", "int8_t", "uintptr_t", "bool", "va_list", "uint64_t", "int64_t", "off_t", "size_t", "int_least64_t", "uint_least64_t", "int_fast16_t", "int_fast32_t", "int_fast64_t", "uint_fast16_t", "uint_fast32_t", "uint_fast64_t"]

    def write_start(self):
        self.f.write(f"""/*

    AUTOGENERATED DO NOT EDIT!

    Generated by {" ".join(get_args())}
    at {time.ctime()}

*/

#ifndef __TYPES_H_
#define __TYPES_H_

// We don't care about warnings here, they just clutter the cli output.
#pragma GCC diagnostic ignored "-Wall"
""")

        for inc in self.sys_includes:
            self.f.write(f"#include <{inc}>\n")
        
        if self.include_defs:
            exec_dir = os.path.dirname(sys.executable)
            defs_path = os.path.join(exec_dir, "plugins", "defs.h")
            with open(defs_path, "r") as f:
                self.f.write(f.read().replace("typedef int bool;", ""))
        self.f.write("#define __fastcall \n")
        self.f.write("#define __cdecl \n")
        self.f.write("\n\n")

    def write_end(self):
        self.f.write("\n\n")
        self.f.write("#endif /* __TYPES_H_ */\n")

    def print_type(self, ti: ida_typeinf.tinfo_t):
        return ti._print(ti.get_type_name(), ida_typeinf.PRTYPE_DEF | ida_typeinf.PRTYPE_MULTI | ida_typeinf.PRTYPE_SEMI | ida_typeinf.PRTYPE_NORES, 4, 0, "")

    def write_type(self, ti: ida_typeinf.tinfo_t):
        name = ti.get_type_name()
        if name in self.blocked:
            return
        ordinal = ti.get_ordinal()
        if ordinal in self.handled_ordinals:
            return
        num_members = ti.get_udt_nmembers()
        for i in range(num_members):
            mem = ida_typeinf.udt_member_t()
            mem.offset = i
            ti.find_udt_member(mem, ida_typeinf.STRMEM_INDEX)
            self.log.info("Member %s.%s (%s)", name, mem.name, mem.type)
            t: ida_typeinf.tinfo_t = mem.type
            # dereference type!
            while t.is_ptr_or_array() and not t.is_funcptr():
                t = t.get_ptrarr_object()
            if t.is_funcptr():
                nargs = t.get_nargs()
                for k in range(nargs):
                    argt = t.get_nth_arg(k)
                    if argt.get_ordinal() > 0:
                        self.write_type(argt)
            if t.get_ordinal() > 0 and t.get_ordinal() != ordinal:
                self.write_type(t)
            else:
                self.log.debug("Member %s.%s (%s)", name, mem.name, mem.type)

        if ti.is_decl_typedef():
            next_type = ti.get_next_type_name()
            if next_type is not None:
                self.log.debug("Resolving typedef %s %s", next_type, name)
                # first put typedef'd thingy majig
                idati = ida_typeinf.get_idati()
                refd = ida_typeinf.tinfo_t()
                if not refd.get_named_type(idati, next_type):
                    self.log.warning("Type %s is typedef, but we couldn't get the next type, this means, we cannot guarantue the resulting c file will compile (refd type might appear later).", name)
                else:
                    self.log.debug("Resolved typedef %s %s -> %d", next_type, name, refd.get_ordinal())
                    self.write_type(refd)

        cmt = f"#{ti.get_ordinal()}, num_udt_members: {ti.get_udt_nmembers()}"
        cmt = "\n".join([f"\t{l}" for l in cmt.splitlines()])
        self.f.write(f"/*\n{cmt}\n*/\n")
        defstr = self.print_type(ti)
        td_obj = None
        if ti.is_enum():
            bt = ti.get_enum_base_type()
            if bt == ida_typeinf.BT_INT64:
                self.log.warning("Type %s has base of int64 will lead to compiler errors!", name)
                defstr = defstr.replace("enum : __int64", "enum")
            td_obj = "enum"
        if ti.is_struct():
            td_obj = "struct"
        if ti.is_union():
            td_obj = "union"
        if td_obj is not None:
            defstr: str
            if defstr.startswith(td_obj):
                lines = defstr.split("\n")
                lines[0] = lines[0] + " " + name
                defstr = "\n".join(lines)
        if ti.is_decl_typedef:
            self.f.write("typedef ")
        self.f.write(defstr)
        self.f.write("\n\n")
        if ordinal != 0:
            self.handled_ordinals.add(ordinal)

    def gen(self):
        self.log.info("Saving type information to %s, cwd: %s", self.outfile, os.getcwd())
        self.f = open(self.outfile, "w")
        self.write_start()
        idati = ida_typeinf.get_idati()
        for ordinal in range(1, ida_typeinf.get_ordinal_qty(idati)+1):
            ti = ida_typeinf.tinfo_t()
            if ti.get_numbered_type(idati, ordinal):
                self.log.debug("Processing type %d (%s)", ordinal, ti.get_type_name())
                self.write_type(ti)
        self.write_end()
        self.f.close()


