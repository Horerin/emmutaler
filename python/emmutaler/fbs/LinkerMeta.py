# automatically generated by the FlatBuffers compiler, do not modify

# namespace: fbs

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class LinkerMeta(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAsLinkerMeta(cls, buf, offset):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = LinkerMeta()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def LinkerMetaBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x53\x52\x4F\x4D", size_prefixed=size_prefixed)

    # LinkerMeta
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # LinkerMeta
    def Text(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            x = o + self._tab.Pos
            from emmutaler.fbs.LinkedSection import LinkedSection
            obj = LinkedSection()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # LinkerMeta
    def TextSize(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # LinkerMeta
    def DataRoStart(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # LinkerMeta
    def Data(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = o + self._tab.Pos
            from emmutaler.fbs.LinkedSection import LinkedSection
            obj = LinkedSection()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # LinkerMeta
    def Bss(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = o + self._tab.Pos
            from emmutaler.fbs.LinkedSection import LinkedSection
            obj = LinkedSection()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # LinkerMeta
    def Stacks(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = o + self._tab.Pos
            from emmutaler.fbs.VirtualSegment import VirtualSegment
            obj = VirtualSegment()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # LinkerMeta
    def PageTables(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = o + self._tab.Pos
            from emmutaler.fbs.VirtualSegment import VirtualSegment
            obj = VirtualSegment()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # LinkerMeta
    def HeapGuard(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # LinkerMeta
    def BootTrampoline(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = o + self._tab.Pos
            from emmutaler.fbs.LinkedSection import LinkedSection
            obj = LinkedSection()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # LinkerMeta
    def BootTrampolineDest(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

def LinkerMetaStart(builder): builder.StartObject(10)
def LinkerMetaAddText(builder, text): builder.PrependStructSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(text), 0)
def LinkerMetaAddTextSize(builder, textSize): builder.PrependUint64Slot(1, textSize, 0)
def LinkerMetaAddDataRoStart(builder, dataRoStart): builder.PrependUint64Slot(2, dataRoStart, 0)
def LinkerMetaAddData(builder, data): builder.PrependStructSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)
def LinkerMetaAddBss(builder, bss): builder.PrependStructSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(bss), 0)
def LinkerMetaAddStacks(builder, stacks): builder.PrependStructSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(stacks), 0)
def LinkerMetaAddPageTables(builder, pageTables): builder.PrependStructSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(pageTables), 0)
def LinkerMetaAddHeapGuard(builder, heapGuard): builder.PrependUint64Slot(7, heapGuard, 0)
def LinkerMetaAddBootTrampoline(builder, bootTrampoline): builder.PrependStructSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(bootTrampoline), 0)
def LinkerMetaAddBootTrampolineDest(builder, bootTrampolineDest): builder.PrependUint64Slot(9, bootTrampolineDest, 0)
def LinkerMetaEnd(builder): return builder.EndObject()

import emmutaler.fbs.LinkedSection
import emmutaler.fbs.VirtualSegment
try:
    from typing import Optional
except:
    pass

class LinkerMetaT(object):

    # LinkerMetaT
    def __init__(self):
        self.text = None  # type: Optional[emmutaler.fbs.LinkedSection.LinkedSectionT]
        self.textSize = 0  # type: int
        self.dataRoStart = 0  # type: int
        self.data = None  # type: Optional[emmutaler.fbs.LinkedSection.LinkedSectionT]
        self.bss = None  # type: Optional[emmutaler.fbs.LinkedSection.LinkedSectionT]
        self.stacks = None  # type: Optional[emmutaler.fbs.VirtualSegment.VirtualSegmentT]
        self.pageTables = None  # type: Optional[emmutaler.fbs.VirtualSegment.VirtualSegmentT]
        self.heapGuard = 0  # type: int
        self.bootTrampoline = None  # type: Optional[emmutaler.fbs.LinkedSection.LinkedSectionT]
        self.bootTrampolineDest = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        linkerMeta = LinkerMeta()
        linkerMeta.Init(buf, pos)
        return cls.InitFromObj(linkerMeta)

    @classmethod
    def InitFromObj(cls, linkerMeta):
        x = LinkerMetaT()
        x._UnPack(linkerMeta)
        return x

    # LinkerMetaT
    def _UnPack(self, linkerMeta):
        if linkerMeta is None:
            return
        if linkerMeta.Text() is not None:
            self.text = emmutaler.fbs.LinkedSection.LinkedSectionT.InitFromObj(linkerMeta.Text())
        self.textSize = linkerMeta.TextSize()
        self.dataRoStart = linkerMeta.DataRoStart()
        if linkerMeta.Data() is not None:
            self.data = emmutaler.fbs.LinkedSection.LinkedSectionT.InitFromObj(linkerMeta.Data())
        if linkerMeta.Bss() is not None:
            self.bss = emmutaler.fbs.LinkedSection.LinkedSectionT.InitFromObj(linkerMeta.Bss())
        if linkerMeta.Stacks() is not None:
            self.stacks = emmutaler.fbs.VirtualSegment.VirtualSegmentT.InitFromObj(linkerMeta.Stacks())
        if linkerMeta.PageTables() is not None:
            self.pageTables = emmutaler.fbs.VirtualSegment.VirtualSegmentT.InitFromObj(linkerMeta.PageTables())
        self.heapGuard = linkerMeta.HeapGuard()
        if linkerMeta.BootTrampoline() is not None:
            self.bootTrampoline = emmutaler.fbs.LinkedSection.LinkedSectionT.InitFromObj(linkerMeta.BootTrampoline())
        self.bootTrampolineDest = linkerMeta.BootTrampolineDest()

    # LinkerMetaT
    def Pack(self, builder):
        LinkerMetaStart(builder)
        if self.text is not None:
            text = self.text.Pack(builder)
            LinkerMetaAddText(builder, text)
        LinkerMetaAddTextSize(builder, self.textSize)
        LinkerMetaAddDataRoStart(builder, self.dataRoStart)
        if self.data is not None:
            data = self.data.Pack(builder)
            LinkerMetaAddData(builder, data)
        if self.bss is not None:
            bss = self.bss.Pack(builder)
            LinkerMetaAddBss(builder, bss)
        if self.stacks is not None:
            stacks = self.stacks.Pack(builder)
            LinkerMetaAddStacks(builder, stacks)
        if self.pageTables is not None:
            pageTables = self.pageTables.Pack(builder)
            LinkerMetaAddPageTables(builder, pageTables)
        LinkerMetaAddHeapGuard(builder, self.heapGuard)
        if self.bootTrampoline is not None:
            bootTrampoline = self.bootTrampoline.Pack(builder)
            LinkerMetaAddBootTrampoline(builder, bootTrampoline)
        LinkerMetaAddBootTrampolineDest(builder, self.bootTrampolineDest)
        linkerMeta = LinkerMetaEnd(builder)
        return linkerMeta
