/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'SecureROM for t8030si, iBoot-4479.0.0.100.4'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long

struct img4;
struct hash_info;
struct ccdigest_ctx;
struct ccdigest_state;
struct ccdigest_info;
struct callout;

/* 1 */
union __attribute__((aligned(8))) __n64
{
  unsigned __int64 n64_u64[1];
  unsigned __int32 n64_u32[2];
  unsigned __int16 n64_u16[4];
  unsigned __int8 n64_u8[8];
  __int64 n64_i64[1];
  __int32 n64_i32[2];
  __int16 n64_i16[4];
  __int8 n64_i8[8];
  float n64_f32[2];
  double n64_f64[1];
};

/* 2 */
union __attribute__((aligned(8))) __n128
{
  unsigned __int64 n128_u64[2];
  unsigned __int32 n128_u32[4];
  unsigned __int16 n128_u16[8];
  unsigned __int8 n128_u8[16];
  __int64 n128_i64[2];
  __int32 n128_i32[4];
  __int16 n128_i16[8];
  __int8 n128_i8[16];
  float n128_f32[4];
  double n128_f64[2];
};

/* 3 */
typedef __n64 int8x8_t;

/* 4 */
typedef __n64 uint8x8_t;

/* 5 */
typedef __n64 int16x4_t;

/* 6 */
typedef __n64 int32x2_t;

/* 7 */
typedef __n64 uint16x4_t;

/* 8 */
typedef __n64 uint32x2_t;

/* 9 */
typedef __n128 int8x16_t;

/* 10 */
typedef __n128 int16x8_t;

/* 11 */
typedef __n128 int32x4_t;

/* 12 */
typedef __n128 int64x2_t;

/* 13 */
typedef __n128 uint8x16_t;

/* 14 */
typedef __n128 uint16x8_t;

/* 15 */
typedef __n128 uint32x4_t;

/* 16 */
typedef __n128 uint64x2_t;

/* 17 */
typedef __n64 poly8x8_t;

/* 18 */
typedef __n64 poly16x4_t;

/* 19 */
typedef __n128 poly16x8_t;

/* 20 */
typedef __n128 poly8x16_t;

/* 21 */
typedef __n64 float32x2_t;

/* 22 */
typedef __n128 float32x4_t;

/* 23 */
typedef __n128 float64x2_t;

/* 24 */
typedef __n128 poly128_t;

/* 25 */
struct __va_list_tag
{
  void *__stack;
  void *__gr_top;
  void *__vr_top;
  int __gr_offs;
  int __vr_offs;
};

/* 26 */
typedef __va_list_tag va_list[1];

/* 27 */
typedef int BOOL;

/* 28 */
enum $F5F7516C06748B7CD451DDD9E15D2ABD
{
  DR_Success = 0x0,
  DR_EndOfSequence = 0x1,
  DR_UnexpectedTag = 0x2,
  DR_DecodeError = 0x3,
  DR_Unimplemented = 0x4,
  DR_IncompleteSeq = 0x5,
  DR_ParamErr = 0x6,
  DR_BufOverflow = 0x7,
};

/* 29 */
typedef enum $F5F7516C06748B7CD451DDD9E15D2ABD DERReturn;

/* 30 */
typedef unsigned __int8 uint8_t;

/* 31 */
typedef unsigned __int16 uint16_t;

/* 32 */
typedef unsigned int uint32_t;

/* 33 */
typedef uint8_t DERByte;

/* 34 */
typedef uint16_t DERShort;

/* 38 */
typedef unsigned __int64 uint64_t;

/* 35 */
typedef uint64_t DERSize;

/* 36 */
struct $99D087C2824D9C2EDC23BDE8F83514A5
{
  DERByte *data;
  DERSize length;
};

/* 37 */
typedef struct $99D087C2824D9C2EDC23BDE8F83514A5 DERItem;

/* 39 */
typedef uint64_t DERTag;

/* 62 */
enum asn1_tag : __int64
{
  ASN1_BOOLEAN = 0x1,
  ASN1_INTEGER = 0x2,
  ASN1_BIT_STRING = 0x3,
  ASN1_OCTET_STRING = 0x4,
  ASN1_NULL = 0x5,
  ASN1_OBJECT_ID = 0x6,
  ASN1_OBJECT_DESCRIPTOR = 0x7,
  ASN1_REAL = 0x9,
  ASN1_ENUMERATED = 0xA,
  ASN1_EMBEDDED_PDV = 0xB,
  ASN1_UTF8_STRING = 0xC,
  ASN1_SEQUENCE = 0x10,
  ASN1_SET = 0x11,
  ASN1_NUMERIC_STRING = 0x12,
  ASN1_PRINTABLE_STRING = 0x13,
  ASN1_T61_STRING = 0x14,
  ASN1_VIDEOTEX_STRING = 0x15,
  ASN1_IA5_STRING = 0x16,
  ASN1_UTC_TIME = 0x17,
  ASN1_GENERALIZED_TIME = 0x18,
  ASN1_GRAPHIC_STRING = 0x19,
  ASN1_VISIBLE_STRING = 0x1A,
  ASN1_GENERAL_STRING = 0x1B,
  ASN1_UNIVERSAL_STRING = 0x1C,
  ASN1_BMP_STRING = 0x1E,
  ASN1_HIGH_TAG_NUMBER = 0x1F,
  ASN1_PRIMITIVE = 0x0,
  ASN1_CONSTRUCTED = 0x2000000000000000,
  ASN1_UNIVERSAL = 0x0,
  ASN1_APPLICATION = 0x4000000000000000,
  ASN1_CONTEXT_SPECIFIC = 0x8000000000000000,
  ASN1_PRIVATE = 0xC000000000000000,
};

/* 114 */
enum der_dec_opts
{
  DER_DEC_OPTIONAL = 0x1,
  DER_DEC_ASN_ANY = 0x2,
  DER_DEC_SKIP = 0x4,
  DER_DEC_SAVE_DER = 0x8,
};

/* 40 */
struct __attribute__((aligned(8))) $A94060D14CF3817FE317AB6880B8F9A5
{
  DERSize offset;
  asn1_tag tag;
  der_dec_opts options;
};

/* 41 */
typedef struct $A94060D14CF3817FE317AB6880B8F9A5 DERItemSpec;

/* 42 */
struct $FE8AD175D3F85C421697EA7C6ED15398
{
  DERTag tag;
  DERItem content;
};

/* 43 */
struct DERDecodedInfo
{
  asn1_tag tag;
  DERItem content;
};

/* 44 */
struct image_info
{
  uint32_t imageLength;
  uint32_t imageAllocation;
  uint32_t imagePrivateMagic;
  uint32_t imageOptions;
  void *imagePrivate;
};

/* 45 */
struct image_properties
{
  bool demote_production_status;
  bool enable_keys;
  bool allow_mix_n_match;
  bool effective_production_status;
  bool valid_effective_production_status;
  bool effective_security_mode;
  bool valid_effective_security_mode;
  uint8_t manifest_hash[48];
  bool valid_manifest;
  bool manifest_hash_verified;
  uint8_t object_digest[48];
};

/* 46 */
struct enviornment_properties
{
  uint64_t chip_id;
  uint64_t unique_chip_id;
  uint64_t chip_epoch;
  uint64_t security_domain;
  uint64_t board_id;
  bool production_status;
  bool security_mode;
  bool local_boot;
  bool verify_manifest_hash;
  bool verify_nonce_hash;
  uint64_t boot_nonce;
  uint8_t boot_manifest_hash[48];
  bool valid_boot_manifest_hash;
  bool uk_bool;
  uint8_t uk_buffer[48];
};

/* 47 */
typedef bool (__fastcall *image4_start_capture_callback)(uint32_t image_type);

/* 48 */
typedef void (__fastcall *image4_boolean_property_callback)(uint32_t tag, bool is_object_property, bool val);

/* 49 */
typedef void (__fastcall *image4_integer_property_callback)(uint32_t tag, bool is_object_property, uint64_t val);

/* 50 */
typedef void (__fastcall *image4_string_property_callback)(uint32_t tag, bool is_object_property, uint8_t *buffer, uint64_t length);

/* 51 */
typedef void (__fastcall *image4_validity_callback)(bool valid);

/* 52 */
struct $2387D6232CC36EB1ED3160A0196E8DD9
{
  bool capture_enabled;
  image4_start_capture_callback start_cb;
  image4_boolean_property_callback bool_cb;
  image4_integer_property_callback int_cb;
  image4_string_property_callback string_cb;
  image4_validity_callback validity_cb;
};

/* 53 */
typedef struct $2387D6232CC36EB1ED3160A0196E8DD9 image4_callbacks;

/* 54 */
struct image4_wrapper_context
{
  img4 *img4;
  enviornment_properties *env_properties;
  image_properties *img_properties;
};

/* 55 */
struct img4_payload
{
  DERItem ident;
  DERItem type;
  DERItem description;
  DERItem raw_data;
  DERItem kbag_vals;
  DERItem unknown;
};

/* 56 */
struct img4_manifest
{
  DERItem ident;
  DERItem version;
  DERItem contents;
  DERItem signature;
  DERItem cert_chain;
};

/* 57 */
struct img4_recovery
{
  DERItem ident;
  DERItem uk_set;
};

/* 58 */
struct __attribute__((aligned(8))) img4
{
  bool verified_stuff;
  bool did_digest;
  DERItem payload_der;
  DERItem manifest_der;
  DERItem man_b;
  DERItem man_p;
  DERItem image_manifest;
  img4_payload payload_items;
  _BYTE payload_der_hash[48];
  img4_manifest manifest_items;
  DERItem some_seq_item;
  _BYTE manifest_der_digest[48];
  _BYTE manifest_item_digest[48];
  img4_recovery recovery_items;
};

/* 59 */
struct ManifestDer
{
  DERItem tag_der;
  _BYTE gap_10[8];
  DERItem contents_der;
  __int64 contents_tag;
};

/* 60 */
struct __attribute__((packed)) __attribute__((aligned(4))) Img4Property
{
  __int64 field_0;
  int field_8;
};

/* 63 */
struct Img4DecodeImplementation
{
  __int64 (__fastcall *do_ccdigest)(DERByte *, DERSize, _BYTE *, _QWORD, __int64);
  __int64 (__fastcall *hasher_8)(DERByte *, DERSize, __int64 *, __int64 *, _BYTE *, _BYTE *, __int64, image4_wrapper_context *);
  __int64 (__fastcall *_verify_signature_rsa_0)(__int64, __int64, DERByte *, DERSize, _BYTE *, _QWORD, __int64, image4_wrapper_context *);
  __int64 (__fastcall *field_18)(img4 *, image4_wrapper_context *);
  hash_info *hasher_info;
};

/* 69 */
struct hash_info
{
  _QWORD hash_size;
  void *more_info;
  const struct ccdigest_info **impl_global;
};

/* 98 */
typedef uint64_t size_t;

/* 97 */
typedef struct ccdigest_state *ccdigest_state_t;

/* 100 */
typedef struct ccdigest_ctx *ccdigest_ctx_t;

/* 99 */
struct ccdigest_info
{
  size_t output_size;
  size_t state_size;
  size_t block_size;
  size_t oid_size;
  const unsigned __int8 *oid;
  const void *initial_state;
  void (__fastcall *compress)(ccdigest_state_t state, size_t nblocks, const void *data);
  void (__fastcall *final)(const struct ccdigest_info *di, ccdigest_ctx_t ctx, unsigned __int8 *digest);
};

/* 90 */
typedef uint64_t cc_unit;

/* 95 */
union ccdigest_state::$2B80EEAE47F7201D863AC3BDFE7BD016
{
  uint8_t u8;
  uint32_t u32;
  uint64_t u64;
  cc_unit ccn;
};

/* 96 */
struct ccdigest_state
{
  union ccdigest_state::$2B80EEAE47F7201D863AC3BDFE7BD016 state;
};

/* 92 */
union ccdigest_ctx::$2B80EEAE47F7201D863AC3BDFE7BD016
{
  uint8_t u8;
  uint32_t u32;
  uint64_t u64;
  cc_unit ccn;
};

/* 93 */
struct ccdigest_ctx
{
  union ccdigest_ctx::$2B80EEAE47F7201D863AC3BDFE7BD016 state;
};

/* 64 */
struct ivkey
{
  uint8_t IV[16];
  uint8_t Key[32];
};

/* 65 */
struct $9EA50B66553804E869A908C505EFBF11
{
  DERByte *nextItem;
  DERByte *end;
};

/* 66 */
typedef struct $9EA50B66553804E869A908C505EFBF11 DERSequence;

/* 67 */
struct $E9C38419BDCFDC0EC3F9F9B96CABC969
{
  DERItem content;
  DERTag tag;
};

/* 68 */
typedef struct $E9C38419BDCFDC0EC3F9F9B96CABC969 DERDecodedInfoFind;

/* 70 */
typedef int __signed;

/* 71 */
typedef __int16 int16_t;

/* 72 */
typedef int int32_t;

/* 73 */
typedef __int64 int64_t;

/* 74 */
typedef int int8_t;

/* 75 */
typedef int16_t int_least16_t;

/* 76 */
typedef int32_t int_least32_t;

/* 77 */
typedef int64_t int_least64_t;

/* 78 */
typedef uint8_t uint_least8_t;

/* 79 */
typedef uint16_t uint_least16_t;

/* 80 */
typedef uint32_t uint_least32_t;

/* 81 */
typedef uint64_t uint_least64_t;

/* 82 */
typedef int8_t int_fast8_t;

/* 83 */
typedef int16_t int_fast16_t;

/* 84 */
typedef int32_t int_fast32_t;

/* 85 */
typedef int64_t int_fast64_t;

/* 86 */
typedef uint8_t uint_fast8_t;

/* 87 */
typedef uint16_t uint_fast16_t;

/* 88 */
typedef uint32_t uint_fast32_t;

/* 89 */
typedef uint64_t uint_fast64_t;

/* 91 */
typedef int64_t cc_int;

/* 101 */
struct list_node
{
  struct list_node *prev;
  struct list_node *next;
};

/* 102 */
enum task_state
{
  TASK_INITIAL = 0x0,
  TASK_READY = 0x1,
  TASK_RUNNING = 0x2,
  TASK_BLOCKED = 0x3,
  TASK_SLEEPING = 0x4,
  TASK_FINISHED = 0x5,
};

/* 103 */
typedef int __uint128_t;

/* 104 */
struct arch_task
{
  uint64_t regs[29];
  uint64_t fp;
  uint64_t lr;
  uint64_t sp;
};

/* 105 */
typedef __uint128_t uint128_t;

/* 106 */
union arch_task::$8508C8049871541BDE60532175466754
{
  uint128_t q;
  uint64_t d;
  uint32_t s;
};

/* 107 */
typedef uint64_t utime_t;

/* 109 */
typedef void (__fastcall *callout_func)(struct callout *, void *);

/* 108 */
struct callout
{
  struct list_node list;
  uint64_t sched_ticks;
  utime_t delay;
  callout_func callback;
  void *arg;
};

/* 110 */
struct task_wait_queue
{
  struct list_node task_list;
};

/* 111 */
typedef int (__fastcall *task_routine)(void *);

/* 112 */
struct task
{
  int magic;
  struct list_node task_list_node;
  struct list_node queue_node;
  enum task_state state;
  int irq_disable_count;
  struct arch_task arch;
  struct callout sleep_callout;
  struct task_wait_queue return_waiters;
  int return_code;
  task_routine routine;
  void *arg;
  void *stack_base;
  size_t stack_len;
  char name[16];
  int task_id;
  int magic2;
};

/* 113 */
#pragma pack(push, 1)
struct chain_verification
{
  DERItem certblob;
  DERItem chain[3];
  _QWORD field_40;
  _BYTE gap_48[40];
  DERItem field_70;
  _BYTE gap_80[80];
  __int64 field_D0;
  _BYTE gap_D8[72];
  _BYTE *field_120;
  __int64 field_128;
  _BYTE gap_130[112];
  _BYTE *field_1A0;
  _QWORD field_1A8;
  _BYTE gap_1B0[256];
  _QWORD field_2B0;
  _BYTE gap_2B8[8];
  _QWORD field_2C0;
  _QWORD field_2C8;
  _BYTE gap_2D0[16];
  __int64 field_2E0;
  _BYTE gap_2E8[8];
  DERByte *field_2F0;
  DERSize field_2F8;
};
#pragma pack(pop)

/* 115 */
enum boot_device
{
  BOOT_DEVICE_NOR = 0x0,
  BOOT_DEVICE_SPI = 0x1,
  BOOT_DEVICE_NAND = 0x2,
  BOOT_DEVICE_NVME = 0x3,
  BOOT_DEVICE_USBDFU = 0x4,
  BOOT_DEVICE_TBTDFU = 0x5,
  BOOT_DEVICE_XMODEM = 0x6,
};

/* 116 */
struct boot_config
{
  boot_device device;
  uint32_t flag;
};

/* 117 */
typedef uint32_t block_addr;

/* 118 */
typedef uint64_t off_t;

/* 119 */
struct blockdev
{
  struct blockdev *next;
  uint32_t flags;
  uint32_t block_size;
  uint32_t block_count;
  uint32_t block_shift;
  uint64_t total_len;
  uint32_t alignment;
  uint32_t alignment_shift;
  int (__fastcall *read_hook)(struct blockdev *, void *ptr, off_t offset, uint64_t len);
  int (__fastcall *read_block_hook)(struct blockdev *, void *ptr, block_addr block, uint32_t count);
  int (__fastcall *write_hook)(struct blockdev *, const void *ptr, off_t offset, uint64_t len);
  int (__fastcall *write_block_hook)(struct blockdev *, const void *ptr, block_addr block, uint32_t count);
  int (__fastcall *erase_hook)(struct blockdev *, off_t offset, uint64_t len);
  char name[16];
  off_t protect_start;
  off_t protect_end;
};

/* 120 */
struct image4_info
{
  struct list_node node;
  struct blockdev *bdev;
  off_t devOffset;
  struct image_info image_info;
};

/* 121 */
enum boot_target
{
  BOOT_UNKNOWN = 0x0,
  BOOT_HALT = 0x1,
  BOOT_IBOOT = 0x2,
  BOOT_DARWIN = 0x3,
  BOOT_DARWIN_RESTORE = 0x4,
  BOOT_DIAGS = 0x5,
  BOOT_TSYS = 0x6,
  BOOT_SECUREROM = 0x7,
  BOOT_MONITOR = 0x8,
  BOOT_DALI = 0x9,
};

/* 122 */
typedef unsigned __int64 uintptr_t;

/* 123 */
struct nor_blockdev
{
  struct blockdev bdev;
  uintptr_t handle;
  int (__fastcall *readRange)(uintptr_t handle, uint8_t *ptr, uint32_t offset, uint32_t length);
  int (__fastcall *writeRange)(uintptr_t handle, const uint8_t *ptr, uint32_t offset, uint32_t length);
  int (__fastcall *eraseRange)(uintptr_t handle, uint32_t offset, uint32_t length);
};

/* 124 */
typedef unsigned int u_int32_t;

/* 125 */
struct spi_ndev
{
  struct nor_blockdev ndev;
  u_int32_t spiBus;
  u_int32_t spiChipSelect;
  u_int32_t spiFrequency;
  u_int32_t spiMode;
  u_int32_t jedecID;
  u_int32_t flags;
  u_int32_t blockSize;
  u_int32_t blockCount;
  u_int32_t softWriteProtectMask;
  u_int32_t progMaxLength;
  u_int32_t progAlignMask;
  u_int32_t defaultTimeout;
  u_int32_t byteProgramTimeout;
  u_int32_t eraseSectorTimeout;
};

/* 126 */
struct nvme_bdev
{
  struct blockdev blockdev;
  int nvme_id;
  uint32_t nsid;
  uint32_t max_transfer_blocks;
  uint32_t dummy_blocks;
  uint32_t blocks_per_virtual_block;
  struct list_node node;
};

/* 127 */
typedef struct nvme_bdev nvme_bdev_t;

/* 129 */
struct nand_blockdev
{
  struct blockdev bdev;
  uintptr_t handle;
  int (__fastcall *readRange)(uintptr_t handle, uint8_t *ptr, uint32_t offset, uint32_t length);
};

/* 128 */
struct __attribute__((packed)) __attribute__((aligned(4))) spi_nand_blockdev
{
  struct nand_blockdev ndev;
  u_int32_t spiBus;
  u_int32_t spiChipSelect;
  u_int32_t spiFrequency;
  u_int32_t spiMode;
  u_int32_t flags;
  u_int32_t blockSize;
  u_int32_t blockCount;
  u_int32_t softWriteProtectMask;
  u_int32_t progMaxLength;
  u_int32_t progAlignMask;
  u_int32_t defaultTimeout;
  u_int32_t byteProgramTimeout;
  u_int32_t eraseSectorTimeout;
};

/* 130 */
struct $5090A74087FCA804CCC0A9D0D379692B
{
  volatile uint32_t *spclkcon;
  volatile uint32_t *spcon;
  volatile uint32_t *spsta;
  volatile uint32_t *sppin;
  volatile uint32_t *sptdat;
  volatile uint32_t *sprdat;
  volatile uint32_t *sppre;
  volatile uint32_t *spcnt;
  volatile uint32_t *spidd;
  volatile uint32_t *spirto;
  volatile uint32_t *spihangd;
  volatile uint32_t *spiswrst;
  volatile uint32_t *spiver;
  volatile uint32_t *sptdcnt;
  uint32_t clock;
  uint32_t irq;
};

/* 131 */
typedef struct $5090A74087FCA804CCC0A9D0D379692B spi_regs_t;

/* 132 */
enum spi_clk
{
  PCLK = 0x0,
  NCLK = 0x1,
};

/* 133 */
struct task_event
{
  bool signalled;
  uint32_t flags;
  struct task_wait_queue wait;
};

/* 134 */
struct spi_status_t
{
  int bits;
  int clkpol;
  int clkpha;
  enum spi_clk clk;
  int baud;
  bool master;
  bool dma;
  const void *tx_buf;
  size_t tx_pos;
  size_t tx_len;
  void *rx_buf;
  size_t rx_pos;
  size_t rx_len;
  int overrun_errors;
  struct task_event event;
  uint32_t shadow_spcon;
  volatile int tx_complete;
  volatile int rx_complete;
};

/* 135 */
struct heap_block
{
  uint64_t checksum;
  uint32_t _pad[4];
  void *chunk_ptr;
  size_t this_size;
  unsigned __int64 this_free : 1;
  unsigned __int64 prev_free : 1;
  unsigned __int64 prev_size : 62;
  size_t padding_start;
  size_t padding_bytes;
};

/* 136 */
struct free_block
{
  struct heap_block common;
  struct free_block *next_in_bin;
  struct free_block *prev_in_bin;
};

/* 137 */
struct chunk_data
{
  struct heap_block *chunk_base;
  uint32_t chunk_size;
};

/* 138 */
struct new_chunk_data
{
  heap_block *front_sentinel;
  _BYTE gap_8[2560];
  _DWORD free_size_maybe;
  _DWORD field_A0C;
  heap_block *chunk_start;
  char *chunk_end;
};

/* 139 */
typedef void (__fastcall *mib_func_t)(uint32_t oid, void *arg, void *value);

/* 140 */
struct mib_func_spec
{
  mib_func_t func;
  void *arg;
};

/* 141 */
union mib_value
{
  uint32_t v32;
  uint64_t v64;
  bool v_bool;
  void *v_ptr;
  struct mib_func_spec v_func;
};

/* 142 */
struct mib_node
{
  uint32_t node_oid;
  uint32_t node_type;
  union mib_value node_data;
};

/* 143 */
struct ccdrbg_nisthmac_custom
{
  const struct ccdigest_info *di;
  int strictFIPS;
};

/* 144 */
struct ccdrbg_state
{
  const struct ccdrbg_nisthmac_custom *custom;
  uint8_t key[64];
  uint8_t V[64];
  uint64_t reseed_counter;
};

/* 145 */
struct ccdrbg_info
{
  size_t size;
  int (__fastcall *init)(const struct ccdrbg_info *info, struct ccdrbg_state *drbg, size_t entropyLength, const void *entropy, size_t nonceLength, const void *nonce, size_t psLength, const void *ps);
  int (__fastcall *reseed)(struct ccdrbg_state *prng, size_t entropylen, const void *entropy, size_t inlen, const void *in);
  int (__fastcall *generate)(struct ccdrbg_state *prng, size_t outlen, void *out, size_t inlen, const void *in);
  void (__fastcall *done)(struct ccdrbg_state *prng);
  const void *custom;
};

/* 146 */
struct cbuf
{
  void *buf;
  unsigned int head;
  unsigned int tail;
  size_t has;
  size_t len;
  uint32_t len_mask;
  struct task_event *event;
};

